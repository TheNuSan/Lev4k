// Generated with Shader Minifier 1.3.5 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef FRAGMENT_INL_
# define FRAGMENT_INL_

const char *fragment_frag =
 "#version 330\n"
 "#define m1 main\n"
 "uniform int m;"
 "uniform sampler2D sb1;"
 "out vec4 o1;"
 "float s;"
 "vec2 d=vec2(1920,1080);"
 "mat2 v(float s)"
 "{"
   "return mat2(cos(s),sin(s),-sin(s),cos(s));"
 "}"
 "float v(vec3 s,vec3 m)"
 "{"
   "s=abs(s)-m;"
   "return max(s.x,max(s.y,s.z));"
 "}"
 "float n(vec3 m)"
 "{"
   "for(int f=0;f<4;++f)"
     "m.yz*=v(s*.3+f),m.xz*=v(s*.4+f*1.7),m.xy=abs(m.xy)-1.1-sin(s+f);"
   "return v(m,vec3(.1,.4,1));"
 "}"
 "void m1()"
 "{"
   "s=m/44100.;"
   "vec2 f=(gl_FragCoord.xy-d.xy/2)/d.y,v=gl_FragCoord.xy/d.xy;"
   "vec3 i=vec3(0),y=vec3(0,0,-10),t=normalize(vec3(f,1)),o=y;"
   "for(int r=0;r<100;++r)"
     "{"
       "float e=n(o);"
       "if(e<.001)"
         "break;"
       "if(e>100)"
         "break;"
       "o+=t*e;"
     "}"
   "float e=1-clamp(length(o-y)/100,0,1);"
   "i+=clamp(n(o-t),0,1)*e;"
   "i=mix(i,texture(sb1,v).xyz,.95);"
   "o1=vec4(i,1);"
 "}"
 "void m2()"
 "{"
   "s=m/44100.;"
   "vec2 f=gl_FragCoord.xy/d.xy;"
   "vec3 i=vec3(0);"
   "vec2 y=vec2(.005,0);"
   "i.x+=texture(sb1,f-y).x;"
   "i.y+=texture(sb1,f).y;"
   "i.z+=texture(sb1,f+y).z;"
   "o1=vec4(i,1);"
 "}"
 "void m3()"
 "{"
   "vec2 s=gl_FragCoord.xy;"
   "float f=(s.x+s.y*1920)/44100.-.05;"
   "vec2 m=vec2(0);"
   "float i=fract(f);"
   "m+=sin(440.*pow(2.,((4-4.)*12.+mod(floor(f),8))/12.)*6.283*i+sin(f*30))*exp(-i*3)*.7;"
   "m+=(fract(i*55.+sin(f*730)*.2)-.5)*exp(-i*9)*.5;"
   "float y=min(fract(f*2),fract(f*6));"
   "m+=fract(sin(y*342.454)*485.523)*exp(-y*10)*.2*step(mod(f,16),12);"
   "o1=vec4(0,0,m);"
 "}";

#endif // FRAGMENT_INL_
